module Runtime

imports
  libstrc
  libstratego-lib
  Common
  
signature constructors

rules
  // redefined in Stratego
  // smart-Some(|arg) =
  //     <get-syntax-sort> arg => xsort
  //   ; <prim("SUGARJ_unsafe_build", "Some")> [arg] 
  //   ; put-syntax-sort(|<prim("SUGARJ_unsafe_build", "Sort")> ["Option", [xsort]])

rules
  put-syntax-sort(|sort) =
    prim("SUGARJ_put_typesmart_sort", sort)
  get-syntax-sort =
    prim("SUGARJ_get_typesmart_sort") 

rules
  // has-sort = Swap; debug(!"has sort? "); fail
  has-sort = where(try-init-subsort-stack; has-subsort-of)
  
  is-lexical-sort = fail
  
  // has-subsort-of = (try(get-syntax-sort), id); debug-analysis(!"has-subsort-of: "); fail
  has-subsort-of = 
      push-subsort-stack
    ; finally( has-subsort-of-refl <+ has-subsort-unrename <+ has-subsort-of-trans
             , pop-subsort-stack)
  // has-subsort-of = debug-analysis(!"FAIL has-subsort-of: "); fail
  
  try-init-subsort-stack =
    where(Subsort-Stack <+ rules ( Subsort-Stack := [] ))
  push-subsort-stack =
      where(
        strip-annos => pair
      ; (<not(elem)> (pair, <Subsort-Stack>) <+ fatal-err-msg(|"detected loop: "); fail)
      ; rules( Subsort-Stack := [pair | <Subsort-Stack>] ))
  pop-subsort-stack =
    where(rules( Subsort-Stack := <Subsort-Stack; ?[_|<id>]> ))
  
  has-subsort-of-refl =
      ?(xs, Sort("List", [xsort]))
    ; <map(!(<id>, xsort); has-subsort-of)> xs
  has-subsort-of-refl =
      ?(xs, Sort("List", [xsort]))
    ; <map(!(<id>, xsort); has-subsort-of)> xs
  has-subsort-of-refl =
      ?(""#(xs), Sort("Tuple", xsorts))
    ; <equal> (<length> xs, <length> xsorts)
    ; <zip> (xs, xsorts)
    ; map(has-subsort-of)
  has-subsort-of-refl =
      ?(None(), Sort("Option", [_]))
  has-subsort-of-refl =
      ?(Some(x), Sort("Option", [xsort]))
    ; <has-subsort-of> (x, xsort)
  has-subsort-of-refl =
      ?(x, Sort("Alt", [xsort1, xsort2]))
    ; (<has-subsort-of> (x, xsort1) + <has-subsort-of> (x, xsort2))
  has-subsort-of-refl =
      ?(x, xsort)
    ; <is-string> x
    ; <is-lexical-sort> xsort
  has-subsort-of-refl =
      (get-syntax-sort ,id)
    ; sort-match
  
  has-subsort-unrename = (id, unrename-sort); has-subsort-of
  has-subsort-of-trans = fail
  unrename-sort = fail
  
  has-subsort-of-inject(|arg-sort,res-sort) =
  	  ?(term,sup-sort)
      // result to argument
      // ; <debug(!"subsort: ")> (sup-sort, res-sort) 
      ; <sort-match> (sup-sort, res-sort)
      ; where(<repeat(unrename-sort)> arg-sort => unrenamed-arg-sort)
      // ; <debug(!"inject: ")> (unrenamed-arg-sort, res-sort) 
      ; <has-subsort-of> (term, unrenamed-arg-sort)

  sort-match = equal
  sort-match =
      ?(Sort("List", [xsort]), Sort("List", [xsort2]))
    ; <sort-match> (xsort, xsort2)
  sort-match =
      ?(Sort("Option",[xsort1]), Sort("Option",[xsort2]))
    ; (<sort-match> (xsort1, xsort2))
  sort-match =
      ?(Sort("Tuple",xsorts1), Sort("Tuple",xsorts2))
      ; <equal> (<length> xsorts1, <length> xsorts2)
      ; <zip> (xsorts1, xsorts2)
      ; map(sort-match)
  sort-match =
      ?(Sort("Alt",[sort1, sort2]), sort)
    ; (<sort-match> (sort1, sort) + <sort-match> (sort2, sort))
  sort-match =
      ?(sort, Sort("Alt",[sort1, sort2]))
    ; (<sort-match> (sort, sort1) + <sort-match> (sort, sort2))
  sort-match =
      (repeat1(unrename-sort), id)
    ; sort-match

rules
  build-alt-sort-or-fail = 
  	// debug(!"build: ");
  	not(?[]); nub; foldl1(\ (x,y) -> Sort("Alt", [x,y]) \)

signature constructors
  EmptyCollection : Sdf2Sort

rules
  compute-syntax-sort = get-syntax-sort
  compute-syntax-sort = (?[] + ?[_|_]); map(compute-syntax-sort <+ "?")
  compute-syntax-sort = ?""#(<id>); !Sort("Tuple", <map(compute-syntax-sort <+ "?")>)
  compute-syntax-sort = ?None(); !Sort("Option", ["?"])
  compute-syntax-sort = ?Some(<id>); !Sort("Option", [<compute-syntax-sort <+ "?">])

rules
  add-sort(|sort) : (sortz,errors) -> ([sort|sortz],errors)
  add-error(|err) : (sortz,errors) -> (sortz,[err|errors])
  add-error(|cons, arg-term) : (sortz,errors) -> (sortz,[<log-mismatching-sort-error(|cons)> arg-term | errors])
  
  merge-results(s1, s2) =
  	  ?t
  	; <s1> t => (sortz1,errors1)
  	; <s2> t => (sortz2,errors2)
  	; if <?[]> errors1
  	    then if <?[]> errors2
  	           then !(<conc> (sortz1,sortz2), [])
  	           else !(sortz1, [])
  	         end
  	    else if <?[]> errors2
  	           then !(sortz2, [])
  	           else !(<conc> (sortz1,sortz2), <conc> (errors1,errors2))
  	         end
  	  end
  
  return-with-errors(|errors) : t -> (t, errors) where <not(?[])> errors
  return-with-errors(|errors) : t -> t where <?[]> errors
 
  
  log-mismatching-sort-error(|cons) =
  	?(arg, sort);
    not(<compute-syntax-sort> arg);
    where (s := <conc-strings> ("Argument lacks sort annotation:",
                                   "\n    constructor ", cons,
                                   "\n    expected ", <write-to-string> sort,
                                   "\n    in argument ", <strip-annos;write-to-string> arg));
    !s
  
  log-mismatching-sort-error(|cons) =
  	?(arg, sort);
    (<compute-syntax-sort> arg => was);
    where(s := <conc-strings> 
            ("Mismatching argument sort",
             "\n    Constructor ", cons,
             "\n    argument ", <strip-annos;write-to-string> arg, 
             "\n    has sort ", <write-to-string> was,
             "\n    but expected ", <write-to-string> sort));
    !s
